#py scripts/updateBits.py bits/bitList.js
import argparse
import os
import re
from pathlib import Path
from typing import List, Tuple

# Matches:
#   const whatchaDoin = new Bit(...
#   let wherePerry = new Bit(...
#   var curseYou = new Bit(...
#   export const ohTherePerry = new Bit(...
DECL_RE = re.compile(
    r'^\s*(?:export\s+)?(?:const|let|var)\s+([A-Za-z_$][\w$]*)\s*=\s*new\s+Bit\s*\('
)

def find_bit_names(js_text: str) -> List[Tuple[int, str]]:
    out = []
    for i, line in enumerate(js_text.splitlines(), start=1):
        m = DECL_RE.match(line)
        if m:
            out.append((i, m.group(1)))
    return out

def make_exported_version(js_text: str) -> str:
    """Prefix each Bit declaration with 'export ' (idempotent)."""
    out_lines = []
    for line in js_text.splitlines():
        if DECL_RE.match(line) and not line.lstrip().startswith('export '):
            out_lines.append('export ' + line.lstrip())
        else:
            out_lines.append(line)
    return '\n'.join(out_lines) + '\n'

def write_file(path: Path, content: str):
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(content, encoding="utf-8")
    print(f"Wrote {path}")

def generate_globals_js(module_rel_path: str) -> str:
    return f"""// Auto-generated by updateBits.py
// Import all exported bits from the module version
import * as Bits from "{module_rel_path}";

// Expose read-only globals for convenience authoring
for (const [name, obj] of Object.entries(Bits)) {{
  if (!(name in globalThis)) {{
    Object.defineProperty(globalThis, name, {{
      value: obj,
      writable: false,
      configurable: false,
      enumerable: true,
    }});
  }}
}}

// Also export default registry if you ever want to import it
export default Bits;
"""

def generate_d_ts(names, model_rel="../classes/bit.js") -> str:
    lines = "\n".join([f"  const {n}: Bit;" for n in names])
    return f"""// Auto-generated by updateBits.py
import type {{ Bit }} from "{model_rel}";
declare global {{
{lines}
}}
export {{}};
"""

def generate_eslint_globals_json(names):
    import json
    return json.dumps({n: "readonly" for n in names}, indent=2)

def main():
    ap = argparse.ArgumentParser(description="Generate module + globals for Bit list.")
    ap.add_argument("source_js", help="Path to your existing bitList.js (e.g., src/bits/bitList.js)")
    ap.add_argument("--out-dir", default=None, help="Output directory (default: same folder as source_js)")
    ap.add_argument("--module-filename", default="bitList.module.js", help="Filename for exported module version")
    ap.add_argument("--globals-filename", default="globals.js", help="Filename for globals side-effect module")
    ap.add_argument("--dts-filename", default="globals.d.ts", help="Filename for TypeScript declarations")
    ap.add_argument("--models-rel", default="../classes/bit.js", help="Path to Bit type from the .d.ts file (relative)")
    ap.add_argument("--eslint-globals", action="store_true", help="Also write .eslintrc.globals.json mapping names to readonly")
    args = ap.parse_args()

    src = Path(args.source_js).resolve()
    base_dir = Path(args.out_dir).resolve() if args.out_dir else src.parent

    js_text = src.read_text(encoding="utf-8")
    pairs = find_bit_names(js_text)
    if not pairs:
        raise SystemExit("No Bit declarations found.\nExpect lines like: const foo = new Bit(...);")

    names = [name for _, name in pairs]

    # 1) Exported module version
    module_js = make_exported_version(js_text)
    module_path = base_dir / args.module_filename
    write_file(module_path, module_js)

    # 2) globals.js (imports from module file)
    module_rel_path = "./" + os.path.relpath(module_path, base_dir).replace("\\", "/")
    globals_js = generate_globals_js(module_rel_path)
    globals_path = base_dir / args.globals_filename
    write_file(globals_path, globals_js)

    # 3) globals.d.ts (true global declarations)
    dts_text = generate_d_ts(names, model_rel=args.models_rel)
    dts_path = base_dir / args.dts_filename
    write_file(dts_path, dts_text)

    # 4) Optional ESLint globals
    if args.eslint_globals:
        eslint_json = generate_eslint_globals_json(names)
        eslint_path = base_dir / ".eslintrc.globals.json"
        write_file(eslint_path, eslint_json)

    print("\nDone. Next steps:")
    print('  • Ensure ESM is enabled (add "type": "module" to package.json).')
    print(f'  • In episode files, add at the top (once): import "../bits/{Path(args.globals_filename).name}";  // adjust path')
    print(f"  • For IntelliSense, include bits/{Path(args.dts_filename).name} in jsconfig.json, or add per-file /// <reference ...>")
    print("  • Restart TypeScript Server in VS Code (Cmd/Ctrl+Shift+P → Restart TS Server).")

if __name__ == "__main__":
    main()
